<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="content-type">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,700,900%7CRoboto+Mono" rel="stylesheet">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.13/clipboard.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/toolbar/prism-toolbar.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/toolbar/prism-toolbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-scala.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <style type="text/css">
    body {
        font-family: 'Roboto', sans-serif;
        line-height:1.6;
        color:rgb(5,5,5);
        background:rgb(255,255,255);
        max-width:60em;
    }
        code {
            font-family: 'Roboto Mono', monospace;
        }
        
        header pre {
            border:2px solid;
            border-color: firebrick;
            text-align: center;
            padding:0.6em;
            overflow-x:scroll;
        }
        header code {
            font-size:1.6em;
            font-weight:bold;
        }
        ul {
            list-style-type: square;
        }
                a {
            color:darkslategrey;
        }
        a:hover {
            color:darkslateblue;
        }

    
    </style>
    
    
    <title>Capturing Packets with Scala natively with libpcap</title>

<meta name="twitter:title" content="Capturing Packets with Scala natively with libpcap">
<meta property="og:title" content="Capturing Packets with Scala natively with libpcap">
<!-- temporary until we release the work -->
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<meta property="og:url" content="https://www.scalawilliam.com/scala-native-libpcap/">
<link rel="canonical" href="https://www.scalawilliam.com/scala-native-libpcap/">
  <!-- http://ogp.me/ -->
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-12-14">
<meta property="article:modified_time" content="2016-12-14">
<!--<meta property="og:description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
<meta itemprop="description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
<meta name="description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
<meta name="twitter:description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
-->
<meta property="og:site_name" content="Scala William">
<link rel="author" href="https://plus.google.com/u/0/103489630517643950426/">
<link rel="publisher" href="https://plus.google.com/u/0/103489630517643950426/">
<meta itemprop="name" content="The most important Streaming abstraction">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/2464813/21297891/f9e3ac96-c5c2-11e6-868c-2dd405e7b028.png">
<meta itemprop="image" content="https://cloud.githubusercontent.com/assets/2464813/21297891/f9e3ac96-c5c2-11e6-868c-2dd405e7b028.png">
<meta name="twitter:image" content="https://cloud.githubusercontent.com/assets/2464813/21297891/f9e3ac96-c5c2-11e6-868c-2dd405e7b028.png">
<meta name="author" content="William Narmontas">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@ScalaWilliam">
</head>
<body>
    <header>
        <h1>Capturing Packets with Scala natively with libpcap</h1>
        <h2>By <a href="/">William "Scala William" Narmontas</a></h2>
        <p>You can browse all the Scala code relating to this here: <a href="https://github.com/ScalaWilliam/scala-native-libpcap">GitHub repository</a></p>
    </header>

<section>
    <h2>Background</h2>
    <p><a href="https://en.wikipedia.org/wiki/Pcap">libcap</a> (also: <a href="http://www.tcpdump.org/pcap.html">pcap</a>) is a <a href="https://en.wikipedia.org/wiki/Packet_analyzer">network traffic capture library</a>. Packet analysis has <a href="https://en.wikipedia.org/wiki/Packet_analyzer#Uses">many use cases</a>, good and bad.</p>
    <p>Last year for a client I wrote a packet analyser to extract current cell tower IDs for mobile network subscribers.
        The <a href="https://en.wikipedia.org/wiki/GPRS_Tunnelling_Protocol">GPRS Tunnelling Protocol (GTP)</a> runs over UDP and is mostly binary encoded (see the <a href="http://www.etsi.org/deliver/etsi_ts/129200_129299/129274/12.06.00_60/ts_129274v120600p.pdf">GTPv2 specification</a> &mdash; large PDF!), and in this particular use case the extraction had to be done real-time.</p>
    <p><a href="https://www.pcap4j.org/">Pcap4j</a> has a nice usable API but its performance didn't match the performance expectation.
        Pcap4j uses <a href="https://github.com/java-native-access/jna/blob/master/README.md">Java Native Access (JNA)</a>
        as the native access layer, which is <a href="http://stackoverflow.com/a/22289269/2789308">slower but easier</a> than <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">JNI (Java Native Interface)</a>. JNI gives a good 25x performance boost over JNA  but required a bit of C-Java interfacing. Fortunately, Scala people have made it easy with the <a href="https://github.com/jodersky/sbt-jni">sbt-jni</a> <a href="https://www.scalawilliam.com/essential-sbt/">SBT (Scala Build Tool)</a> plugin.</p>
    <p>I was then able to test-drive my development <a href="https://www.youtube.com/watch?v=6e89HsqJtXQ">with ScalaTest</a> and Scala's <a href="http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html">type classes</a>. The type classes let me write a purely functional access layer to both <a href="http://doc.akka.io/api/akka/2.4/akka/util/ByteString.html">ByteString</a> and zero-copy direct high performance memory access via <a href="https://dzone.com/articles/understanding-sunmiscunsafe">using sun.misc.Unsafe</a>.</p>
    <p>You can run your analysis online against a live interface or offline against a file that you would capture with <a href="https://danielmiessler.com/study/tcpdump/">tcpdump</a>. To visually analyse the packets you'd use <a href="https://www.wireshark.org/">Wireshark</a>.</p>
    </section>
    <section>
        <h2><a href="http://www.scala-native.org/">scala-native</a></h2>
        <p>As soon as I saw <a href="http://www.scala-lang.org/blog/2017/03/14/scala-native-0.1-is-here.html">scala-native 0.1</a> announced, I rushed to see how well it'd work with libpcap. I loaded up a <a href="https://github.com/ScalaWilliam/scala-native-sbt-docker">Docker image</a>, installed <code>libpcap-dev</code> and got to work.</p>
        <p>This was significant for me because it means it's possible to go beyond even the limits of JVM-JNI bridge and simply work natively with zero performance impact while still benefitting from potentially testing your code in fast iterations with ScalaTest.</p>
        <p>scala-native's native library interface is pretty much the same as JNA, but I'd expect very high performance.
        So you would not need to write any C code to get the native access.</p>
    </section>
    <section>
        <h2>Getting to work</h2>
        <section>
            <h3>Dealing with null pointers</h3>
        <p>This wasn't too bad, <code>NULL</code> is <code>null</code>!</p>
        <pre class="language-scala"><code data-source="src/main/scala/PcapExample.scala" data-from="93" data-to="93">if (pcapHandle == null) {</code></pre>
        </section>
        <section>
            <h3>Understanding Scala-C mappings</h3>
            <p><a href="http://www.scala-native.org/en/latest/user/interop.html">The documentation</a> (<a href="https://media.readthedocs.org/pdf/scala-native/latest/scala-native.pdf">PDF</a>) was good and helpful, there was not much surprise.</p>
        </section>
        <section>
            <h3>Mapping libpcap to Scala</h3>
            <p>Was a bit more effort initially - <a href="https://linux.die.net/man/3/pcap_open_live">some</a> <a href="http://www.tcpdump.org/manpages/pcap_open_live.3pcap.html">manpages</a>.
            </p>
            <p>
        <a href="https://fossies.org/dox/libpcap-1.8.1/pcap_2pcap_8h_source.html#l00163">Reading the source</a> was the most helpful thing and 
                from this I managed to build a good simple mapping:</p>
            <pre class="language-scala"><code data-source="src/main/scala/pcap.scala" data-from="9" data-to="36">@native.link("pcap")
@native.extern
object pcap {

  /** This is just a pointer for us, we don't care what is inside **/
  type pcap_handle = native.Ptr[Unit]

  type pcap_pkthdr = native.CStruct4[native.CUnsignedLong,
                                     native.CUnsignedLong,
                                     native.CUnsignedInt,
                                     native.CUnsignedInt]

  def pcap_open_live(deviceName: CString,
                     snapLen: CInt,
                     promisc: CInt,
                     to_ms: CInt,
                     errbuf: CString): pcap_handle =
    native.extern

  def pcap_open_offline(fname: CString, errbuf: CString): pcap_handle =
    native.extern

  def pcap_next(p: native.Ptr[Unit],
                h: native.Ptr[pcap_pkthdr]): native.CString = native.extern

  def pcap_close(p: native.Ptr[Unit]): Unit = native.extern

}</code></pre>
            </section>
        <section>
        <h3>Testing offline</h3>
            
            <p>I wanted to make sure I can read from a simple static file. Producing one isn't too difficult - just run a <a href="http://www.speedtest.net/">speed test</a> while capturing your packets with <a href="http://www.tcpdump.org/">tcpdump</a>.</p>
            <p>For offline reading, you need <a href="http://www.tcpdump.org/manpages/pcap_open_offline.3pcap.html"><code>pcap_open_offline</code></a>.</p>
            <p>With every code change, my app would <a href="https://www.scalawilliam.com/essential-sbt/#run-continuously">run continuously</a> using <a href="http://www.scala-sbt.org/0.13/docs/Triggered-Execution.html">SBT's triggered execution</a> but there would be nasty crashes (exit code 139 and such) if I got something wrong with memory access.</p>
            </section>
        <section>
            <h3>Reading the first packet</h3>
            <p>Now that I managed to read one packet without crashing, I finally got access to the timestamps, but the results were odd - turns out I was reading <code>Int</code> and not <code>Long</code>. But this happens even in Java where developers dislike using <code>java.time.*</code>.</p>
        </section>
        <section>
            <h3>Online vs Offline</h3>
            <p>In online, reading the next packet you may get a <code>null</code> as result, telling you you just need to retry for the next packet - whereas in offline this means the end of the file.</p>
        </section>
        <section>
            <h3>Pointer manipulation</h3>
            <p>To read the data, and in a high performance manner, we have to deal with pointer manipulation and be super extremely safe when doing so. Poor understanding of pointers is where <a href="https://en.wikipedia.org/wiki/Dangling_pointer">many bugs come from</a>.</p>
            <p>Data copying has a huge performance penalty so by accessing the memory directly we don't copy very much.
                pcap however does copy from kernel to user space and if you wanted to avoid that there are <a href="https://en.wikipedia.org/wiki/Netsniff-ng">solutions</a> <a href="http://www.ntop.org/products/packet-capture/pf_ring/pf_ring-zc-zero-copy/">for that</a> but it's beyond scope.</p>
        </section>
        <section>
            <h3>Printing IP addresses</h3>
            <p>This was one thing that was easier in native land than in JVM land. As far as I'm aware there is no <a href="https://linux.die.net/man/3/inet_ntoa"><code>inet_ntoa</code></a> in the JVM to convert an IP address from Int into text form.
                This was easily achievable by native binding.
            </p>
             <pre class="language-scala"><code data-source="src/main/scala/inet.scala" data-from="6" data-to="15">/**
  * We use this to avoid our own byte manipulation.
  * Ironically I have to do this with bytes in Java, so scala-native is already proving itself!
  */
@native.extern
object inet {

  def inet_ntoa(input: CUnsignedInt): native.CString = native.extern

}</code></pre>
            <p>And a bit of conversion to a Scala String:</p>
             <pre class="language-scala"><code data-source="src/main/scala/PcapExample.scala" data-from="61" data-to="65">val destIp = {
  val ip = !(data + PcapDestinationIpv4AddressOffset + offsetBytes)
    .cast[Ptr[CUnsignedInt]]
  fromCString(inet.inet_ntoa(ip))
}</code></pre>
        </section>
        <section>
            <h3>Running against a live interface</h3>
            <pre class="language-scala"><code data-source="src/main/scala/PcapExample.scala" data-from="82" data-to="88">pcap.pcap_open_live(
  deviceName = toCString("any"),
  snapLen = Short.MaxValue,
  promisc = 0,
  to_ms = 10,
  errbuf = errorBuffer
)</code></pre>
            <p>If you're capturing from all interfaces on Linux, be aware of the <a href="https://wiki.wireshark.org/SLL">Linux cooked-mode capture (SLL)</a> which <a href="https://ask.wireshark.org/questions/21562/editcap-from-linux-cooked-capture-to-ethernet-packet">can be</a> <a href="https://www.wireshark.org/lists/ethereal-users/200412/msg00314.html">confusing</a>.</p>
        </section>
        
</section>
    
        <section>
        <h2>Running for yourself</h2>
        <p>...so you can reproduce this yourself</p>
        <h3>1. Capture some packets</h3>
            <pre class="language-bash"><code>$ tcpdump -i [interface] -w sample.pcap</code></pre>
        <p>Terminate the command when you wish.</p>
        <h3>2. Clone the repository</h3>
            <pre class="language-bash"><code>$ git clone https://github.com/ScalaWilliam/scala-native-libpcap</code></pre>
        <h3>3. Run the app in Docker against the captured file</h3>
        <pre class="language-bash"><code>$ docker run -v $PWD:/me -w /me/scala-native-libpcap -it scalawilliam/scala-native-sbt
root@0c957f870d61:/me/scala-native-libpcap# apt-get -y install libpcap-dev
root@0c957f870d61:/me/scala-native-libpcap# sbt clean 'show nativeLink'
...
[info] /me/scala-native-libpcap/target/scala-2.11/scala-native-libpcap-out
[success] Total time: 37 s, completed Mar 26, 2017 3:49:38 AM
root@0c957f870d61:/me/scala-native-libpcap# /me/scala-native-libpcap/target/scala-2.11/scala-native-libpcap-out /me/sample.pcap |head
Time: 1490492402, 192.168.1.53 --&gt; 74.125.68.149, 790 bytes: [1C872...]       &lt;-- Google
Time: 1490492402, 74.125.68.149 --&gt; 192.168.1.53, 579 bytes: [38C9E...]       &lt;-- Google
Time: 1490492403, 192.168.1.53 --&gt; 104.16.59.5, 54 bytes: [1C872...]          &lt;-- CloudFare
Time: 1490492403, 104.16.59.5 --&gt; 192.168.1.53, 64 bytes: [38C98...]          &lt;-- CloudFare
...</code></pre>
        <h3>4. Running against a live interface</h3>
        <p>Exercise for the reader!</p>
        </section>
    
    <section>
        <h2>Impact</h2>
        <p>scala-native opens up a plethora of integration opportunities: you are no longer restricted to using
        JVM-only libraries or waiting for those wrappers, no longer restricted to using C++/C for lower level or high performance programming. You can now rapidly iterate and test your code in JVM mode and port it to native easily.</p>
        <p>This opens up the possibility of native interoperation with Python and Lua - and from JVM via Luaj, jyp and Jython.</p>
        <p>You can write your application in the JVM first knowing you can potentially scale it out later, should the JVM be the pain point. Though in my experience it really isn't, but still worth having that possibility.</p>
    </section>
    
    <section>
        <h2>Conclusion</h2>
        <p>We managed to read offline and online packets using a native packet capture library and Scala.</p>
        <p>There were no major difficulties while doing so, proving scala-native is a viable platform for native applications in future.</p>
        
        
        <p>I also came across some interesting (<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.194.18&amp;rep=rep1&amp;type=pdf">PDF</a>) reading about packet capture. and learned that <a href="https://linuxconfig.org/how-to-install-missing-ifconfig-command-on-debian-linux">ifconfig is missing from latest Debian</a>!</p>
        
    </section>
    <section>
    <h2>Base example</h2>
        <h3>while-loop</h3>
    <section>
        <h2>Social media</h2>
    <h3>Share on Twitter</h3>
    <blockquote class="twitter-tweet" data-cards="hidden" data-lang="en"><p lang="en" dir="ltr">Just wrote this: <a href="https://t.co/TXQbzeKL2y">https://t.co/TXQbzeKL2y</a> <br>It's a draft but important enough to go out :) <a href="https://twitter.com/hashtag/streaming?src=hash">#streaming</a> <a href="https://twitter.com/hashtag/kafka?src=hash">#kafka</a> <a href="https://twitter.com/hashtag/reactive?src=hash">#reactive</a> <a href="https://twitter.com/hashtag/akka?src=hash">#akka</a> <a href="https://twitter.com/hashtag/scala?src=hash">#scala</a> <a href="https://twitter.com/hashtag/jvm?src=hash">#jvm</a></p>&#8212; William Narmontas (@ScalaWilliam) <a href="https://twitter.com/ScalaWilliam/status/808830321743433728">December 14, 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
        
        <h3>Share</h3>
                <div class="addthis_inline_share_toolbox"></div>
        <h3>Follow</h3>
        <style type="text/css">
        #atftbx > p > span { display:none; }
        </style>
        <div class="addthis_inline_follow_toolbox"></div>

        <h3>My other articles</h3>
        <ul>
        	    <li><a href="https://medium.com/@ScalaWilliam/limit-degrees-of-freedom-in-development-4c543bb6f806#.xmrcpl8rg">Limit degrees of freedom in development
		    </a></li>
    <li><a href="https://www.scalawilliam.com/essential-sbt/">Essential SBT</a></li>
        <li><a href="https://hackernoon.com/feature-switches-inheritance-and-agile-with-scala-jmx-on-the-jvm-140b4bf94d9f?gi=d8324d17dca0#.vj0o8770w" target="_blank">Feature Switches, Inheritance and Agile with Scala &amp; JMX on the JVM</a></li>

        </ul>
        
        <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-584b716cc10a0e3c"></script>

    </section>
</section></body></html>