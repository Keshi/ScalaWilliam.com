<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="content-type">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,700,900%7CRoboto+Mono" rel="stylesheet">
<title>The most important Streaming abstraction</title>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.13/clipboard.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/toolbar/prism-toolbar.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/toolbar/prism-toolbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-scala.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <style type="text/css">
    body {
        font-family: 'Roboto', sans-serif;
        line-height:1.6;
        color:rgb(5,5,5);
        background:rgb(255,255,255);
        max-width:60em;
    }
        code {
            font-family: 'Roboto Mono', monospace;
        }
        
        header pre {
            border:2px solid;
            border-color: firebrick;
            text-align: center;
            padding:0.6em;
        }
        header code {
            font-size:1.6em;
            font-weight:bold;
        }
    
    </style>
    
    
    
    
        <meta property="og:url" content="https://www.scalawilliam.com/most-important-streaming-abstraction/">
  <!-- http://ogp.me/ -->
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-12-14">
<meta property="article:modified_time" content="2016-12-14">
<meta property="og:title" content="The most important Streaming abstraction">
<meta property="og:image" content="https://avatars3.githubusercontent.com/u/2464813">
<meta property="og:description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
<meta itemprop="description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
<meta name="description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
<meta name="twitter:description" content="The most important streaming abstraction: how do you separate out the pure from the impure to create extremely reusable code?">
<meta property="og:site_name" content="Scala William">
    <link rel="author" href="https://plus.google.com/u/0/103489630517643950426/">
<link rel="publisher" href="https://plus.google.com/u/0/103489630517643950426/">
<meta itemprop="name" content="The most important Streaming abstraction">
<meta itemprop="image" content="https://avatars3.githubusercontent.com/u/2464813">
<meta name="author" content="William Narmontas">
<link rel="canonical" href="https://www.scalawilliam.com/most-important-streaming-abstraction/">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@ScalaWilliam">
<meta name="twitter:title" content="The most important Streaming abstraction">
<meta name="twitter:image" content="https://avatars3.githubusercontent.com/u/2464813">

    
    
    
    
    </head>
    
<body>
    <header>
        <h1>The most important Streaming abstraction</h1>
        <h2>By <a href="/">William "Scala William" Narmontas</a></h2>
        <pre><code>accept: (State, Input) =&gt; State</code></pre>
    </header>

<section>
<p>Any mutable, side-effect free code can be rewritten into this form and be reused on any iterator with a `scanLeft` method.</p>
<p>Any mutable, side-effecting code can be rewritten into this form, plus side-effecting code.</p>
<p>When you write code like this, you can reuse it in mutable code, an Iterator, an akka-streams Flow (ie Kafka!),  a tail recursive function and a pure test.</p>
<p>Because this function is not tied to any particular streaming implementation. You can plug it into akka-stream, into an Iterator, into a List, into a ListView, into a while loop, whatever - you are never locked into any one particular way of thinking.</p>
</section>

    <section>
    <h2>Base example</h2>
        <h3>while-loop</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleBasic.scala" data-from="13" data-to="17">var state: State = initialState
while (true) {
  dumpState(state)
  state = accept(state, fetchInput())
}</code></pre>
        <h3>Iterator</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleBasic.scala" data-from="27" data-to="28">iteratorInput()
  .scanLeft(initialState)(accept)</code></pre>
        <h3>akka-streams</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleBasic.scala" data-from="21" data-to="23">flowInput
  .scan(initialState)(accept)
  .runForeach(dumpState)</code></pre>
        <h3>tail recursion</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleBasic.scala" data-from="32" data-to="38">@tailrec
def go(state: State): Unit = {
  dumpState(state)
  go(accept(state, fetchInput()))
}

go(initialState)</code></pre>
    </section>
    
    <section>
    <h2>Transforming state</h2>
    
<p>But suppose you don't want to output the full state however, but just want to emit an <code>Output</code>.
    Your <code>Output</code> can be <code>Iterator[Stuff]</code>, or <code>Either[Bad, Good]</code> Or a <code>Try[Good]</code> or <code>SomeTrait</code> or anything you like.
    </p>
        <h3>while-loop</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleOutput.scala" data-from="13" data-to="17">var state: State = initialState
while (true) {
  dump(extract(state))
  state = accept(state, fetchInput())
}</code></pre>
        <h3>Iterator</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleOutput.scala" data-from="28" data-to="31">iteratorInput()
  .scanLeft(initialState)(accept)
  .map(extract)
  .foreach(dump)</code></pre>
        <h3>akka-streams</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleOutput.scala" data-from="21" data-to="24">flowInput
  .scan(initialState)(accept)
  .map(extract)
  .runForeach(dump)</code></pre>
        <h3>tail recursion</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/SampleOutput.scala" data-from="35" data-to="41">@tailrec
def go(state: State): Unit = {
  dump(extract(state))
  go(accept(state, fetchInput()))
}

go(initialState)</code></pre>
    </section>

    <section>
    <h2>Deduplication state machine</h2>
    <p>We'll deduplicate consecutive items here. Sample usage:</p>
        <pre class="language-scala"><code data-source="src/main/scala/samples/DeduplicationSample.scala" data-from="20" data-to="20">Iterator.apply[String]("X", "Y", "Y").scanLeft(Deduplicate.initial[String])(_.next(_)).flatMap(_.extract)</code></pre>
        <h3>Implementation:</h3>
        <pre class="language-scala"><code data-source="src/main/scala/samples/DeduplicationSample.scala" data-from="6" data-to="17">case class Deduplicate[T](lastSeen: Option[T], emit: Option[T]) {
  def extract: Option[T] = emit

  def next(input: T): Deduplicate[T] = lastSeen match {
    case Some(`input`) =&gt; Deduplicate(Some(input), None)
    case _ =&gt; Deduplicate(Some(input), Some(input))
  }
}

object Deduplicate {
  def initial[T]: Deduplicate[T] = Deduplicate(None, None)
}</code></pre>
        <h3>Testing</h3>
        <p>Look at just how easy it is!</p>
        <pre class="language-scala"><code data-source="src/test/scala/samples/DeduplicationSample$Test.scala" data-from="9" data-to="31">class DeduplicationSample$Test extends FunSuite {

  import DeduplicationSample.Deduplicate.initial

  test("Empty is empty") {
    initial.extract shouldBe empty
  }
  test("Single is emmitted") {
    initial.next("Stuff").extract shouldBe Some("Stuff")
  }
  test("Two in a row makes one emit") {
    initial.next("Stuff").next("Stuff").extract shouldBe empty
  }
  test("Three in a row makes one emit") {
    initial.next("Stuff").next("Stuff").next("Stuff").extract shouldBe empty
  }
  test("X and then Y gives Y at the end") {
    initial.next("X").next("Y").extract shouldBe Some("Y")
  }
  test("X and then Y and then Y gives Y") {
    initial.next("X").next("Y").next("Y").extract shouldBe empty
  }
}</code></pre>
    </section>

    <section>
    <h2>Conclusion</h2>
<p>By using this pure immutable approach, your code can be used from multiple places and even extremely easily tested. Overcomplicate it, and your wiring becomes your "domain logic".</p>

<p>Note that you can reuse this code from now on, in any project, in any sort of implementation. You can even plonk it inside a Free Monad if you wish to do so.
Because it's simple and is the minimal necessary abstraction to get most work done. </p>

<p>You can test the whole thing step-by-step with simple pure functions.</p>

<p>These things can also be called State Machines. Separate pure logic from side effects, that's all.</p>
        </section>
</body></html>